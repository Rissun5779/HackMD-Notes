---
title: æ•¸ä½ç³»çµ±èˆ‡å¯¦ç¿’_æ•¸ä½é‚è¼¯
tags: [æ•¸ä½é‚è¼¯, Verilog]

---

:::info
**æˆèª²æ•™å¸«:é»ƒç‚³æ£®**
**åƒè€ƒæ›¸ç±:Digital Logic Design Using Verilog, Vaibbhav Taraate**
[èª²æœ¬é€£çµ](https://link.springer.com/book/10.1007/978-981-16-3199-3)
:::
### ğŸ’¾**ç›®éŒ„ (Table of Contents)**

- [**è¨ˆæ•¸å™¨ (Counter)**](#ğŸ¥¶è¨ˆæ•¸å™¨ (Counter))
- [**åŠ æ³•å™¨ (Adder)**](#ğŸ‘¾åŠ æ³•å™¨(Adder))
- [**æ¸›æ³•å™¨ (Subtractor)**](#ğŸ‘»æ¸›æ³•å™¨(Subtractor))
- [**åŠ æ¸›æ³•å™¨ (Adder-Subtractor)**](#ğŸ˜¼åŠ æ¸›æ³•å™¨ (Adder-Subtractor))
- [**ä¹˜æ³•å™¨ (Multiplier)**](#ğŸƒä¹˜æ³•å™¨ (Multiplier))
- [**å¤šå·¥å™¨ (Multiplexer, MUX)**](#ğŸ‘¹å¤šå·¥å™¨ (Multiplexer, MUX))
- [**è§£ç¢¼å™¨ (Decoder)**](#ğŸ‘½è§£ç¢¼å™¨ (Decoder))
- [**ç·¨ç¢¼å™¨ (Encoder)**](#ç·¨ç¢¼å™¨ (Encoder))
- [**æ¯”è¼ƒå™¨ (Comparator)**](#ğŸ¤™æ¯”è¼ƒå™¨(Comparator))
- [**é–‚é–å™¨ (Latch)**](#é–‚é–å™¨)
# ğŸ¥¶**è¨ˆæ•¸å™¨ (Counter)** 
- **è¨ˆæ•¸å™¨æ˜¯ä¸€ç¨®åŸºæœ¬çš„æ•¸ä½é›»è·¯å…ƒä»¶ï¼Œç”¨æ–¼è¨ˆç®—äº‹ä»¶çš„ç™¼ç”Ÿæ¬¡æ•¸æˆ–ç¶­è­·ä¸€å€‹æ•¸å­—ç‹€æ…‹ã€‚è¨ˆæ•¸å™¨é€šå¸¸å¯ä»¥æ ¹æ“šå…¶è¨­è¨ˆåˆ†ç‚ºä¸åŒé¡å‹ï¼Œä¸»è¦åŒ…æ‹¬åŒæ­¥è¨ˆæ•¸å™¨ã€ç•°æ­¥è¨ˆæ•¸å™¨ã€å‘ä¸Šè¨ˆæ•¸å™¨ã€å‘ä¸‹è¨ˆæ•¸å™¨ã€ä»¥åŠé›™å‘è¨ˆæ•¸å™¨ã€‚ä»¥ä¸‹æ˜¯é€™äº›è¨ˆæ•¸å™¨çš„ç°¡ä»‹ï¼š**
  - **è¨ˆæ•¸å™¨çš„åŸºæœ¬æ¦‚å¿µ**
    **è¨ˆæ•¸å™¨çš„åŠŸèƒ½ï¼šè¨ˆæ•¸å™¨èƒ½å¤ è¨ˆç®—æ™‚é–“ã€äº‹ä»¶æˆ–è„ˆè¡çš„æ•¸é‡ï¼Œä¸¦ä»¥æ•¸å­—å½¢å¼è¡¨ç¤ºé€™äº›æ•¸é‡ã€‚
    è„ˆè¡è§¸ç™¼ï¼šè¨ˆæ•¸å™¨é€šå¸¸æ˜¯ç”±æ™‚é˜ä¿¡è™Ÿè§¸ç™¼çš„ï¼Œæ¯ç•¶æ™‚é˜ä¿¡è™Ÿæœ‰è®ŠåŒ–ï¼ˆå¦‚ä¸Šå‡æ²¿æˆ–ä¸‹é™æ²¿ï¼‰æ™‚ï¼Œè¨ˆæ•¸å™¨å°±æœƒæ ¹æ“šå…¶è¨­è¨ˆçš„æ–¹å¼å¢åŠ æˆ–æ¸›å°‘è¨ˆæ•¸å€¼ã€‚**
    
### ğŸ”´é€£æ³¢é€²ä½è¨ˆæ•¸å™¨(Ripple_Carry_Counter)
- **æ¶æ§‹:**
&emsp;&emsp;**é€£æ³¢é€²ä½è¨ˆæ•¸å™¨ç”±Då‹è§¸ç™¼å™¨å’Œä¸€å€‹åå‘å™¨çµ„æˆTå‹æ­£åå™¨å†ç”±ï¼Œä¸²è¯Tå‹æ­£åå™¨å³å¯å®Œæˆã€‚**

![ripple-carry-counter](https://hackmd.io/_uploads/S1olo1H-Jx.png)

- **é€£æ³¢é€²ä½è¨ˆæ•¸å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Ripple_Carry_Counter(
  input  clock, reset, 
  output [3:0] q
);
  
  T_FF t0(clock, reset, q[0]),
       t1( q[0], reset, q[1]),
       t2( q[1], reset, q[2]),
       t3( q[2], reset, q[3]);
endmodule 
```
- **Då‹è§¸ç™¼å™¨æ¨¡çµ„**
```verilog=1
module D_FF(
  input  clock, reset, d,
  output reg q
);
  
  always @(posedge reset or negedge clock)
    if(reset)
	   q=1'b0;
	 else 
	   q=d;
endmodule 
```
- **Tå‹è§¸ç™¼å™¨æ¨¡çµ„**
```verilog=1
module T_FF(
  input  clock, reset, 
  output q
);
  
  wire d;
  not(d, q);
  D_FF d1(clock, reset, d, q);
endmodule 
```
- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module stimulus;
  reg  clock, reset;
  wire [3:0] q;
  
  Ripple_Carry_Counter RC(clock, reset, q);
  initial 
    clock=0;
  always #5 clock=~clock;
  
  initial begin
         reset = 1;
	 #15  reset = 0;
	 #180 reset = 1;
	 #10  reset = 0;
	 #20 $finish;
  end
endmodule 
```

- **è¨ˆæ•¸å™¨çš„é‹ä½œé‚è¼¯ç›¸å°è€Œè¨€æˆ‘è¦ºå¾—ç®—æ˜¯å›°é›£çš„ï¼Œå› ç‚ºæ¶‰åŠäº†æŒ¯ç›ªä¹‹é¡çš„æ€§è³ªï¼ŒæŸç¨®ç¨‹åº¦ä¸Šä¹Ÿç®—æ˜¯æœ‰æ™‚åºçš„å½±éŸ¿ï¼Œä½†æ˜¯å¤šåŠ æ·±å…¥æ‡‰ç”¨è‡ªç„¶æœƒæœ‰è±ç„¶é–‹æœ—çš„ä¸€å¤©!**
# ğŸ‘¾**åŠ æ³•å™¨(Adder)** 
- **ç¨®é¡ï¼šåŠ æ³•å™¨å¯åˆ†ç‚ºåŸºæœ¬çš„åŠåŠ å™¨ï¼Œå…¨åŠ å™¨ï¼ˆRipple Carry Adder, CRAï¼‰ã€å‰ç»é€²ä½åŠ æ³•å™¨ï¼ˆCarry Look-Ahead Adder, CLAï¼‰ã€é€²ä½é¸æ“‡åŠ æ³•å™¨ï¼ˆCarry Select Adder, CSAï¼‰ç­‰ã€‚**
**å¯¦å‹™è€ƒé‡ï¼šåœ¨æ›´é«˜æ•ˆèƒ½çš„æ‡‰ç”¨ä¸­ï¼Œæœƒä½¿ç”¨æ›´è¤‡é›œçš„è¨­è¨ˆå¦‚ã€Œè·³èºé€²ä½ã€ï¼ˆSkip Carryï¼‰æˆ–ã€Œä¸¦è¡Œé€²ä½ã€ï¼ˆParallel Carryï¼‰ä¾†é€²ä¸€æ­¥æå‡æ•ˆç‡ã€‚**
### ğŸ”µ**åŠåŠ æ³•å™¨(Half Adder)**
<div style="display: flex; justify-content: space-around;">
  <img src="https://hackmd.io/_uploads/r1cNZoX-ke.png" alt="åœ–ç‰‡" width="60%">
  <img src="https://hackmd.io/_uploads/rkgCUjQZkl.png" alt="åœ–ç‰‡" width="50%">
</div>

- **Boolean Function**
  $Sum=AâŠ•B$
  $Cout=A*B$
```verilog=1
module Half_Adder(
  input  A, B,
  output Sum, Cout
);
  
  xor ( Sum, A, B);
  and (Cout, A, B);
endmodule 
```
  &emsp;&emsp;**ä¾æ“šåŠæ³•å™¨çš„çœŸå€¼è¡¨å’Œé‚è¼¯ç‰¹æ€§æˆ‘å€‘å¯ä»¥å¯«å‡ºä»¥ä¸Šçš„verilogä»£ç¢¼ã€‚**
  <br>
### ğŸ”µ**å…¨åŠ æ³•å™¨(Full Adder)**
<div style="display: flex; justify-content: space-around;">
  <img src="https://hackmd.io/_uploads/HySkdjX-Jl.png" alt="åœ–ç‰‡" width="50%">
  <img src="https://hackmd.io/_uploads/Sk4VKoQ-Jx.png" alt="åœ–ç‰‡" width="30%">
</div>

- **Boolean Function**
  $Sum=AâŠ•BâŠ•Cin$
  $Cout=AB+AC+BC$

```verilog=1
module Full_Adder(
  input  A, B, Cin,
  output Sum, Cout
);
  
 assign Sum  = A^B^Cin;
 assign Cout = A&B|A&Cin|B&Cin;
endmodule 
```

### ğŸ”´**å››ä½å…ƒé€£æ³¢é€²ä½åŠ æ³•å™¨(4 bits Ripple Full Adder)**
![RCA](https://hackmd.io/_uploads/By6whoXZJg.jpg)
- **æ¶æ§‹**
&emsp;&emsp;**ç”±å…¨åŠ æ³•å™¨ä¾åºä¸²è¯è€Œæˆï¼Œæ¯ä¸€å€‹å…¨åŠ å™¨çš„é€²ä½éƒ½æœƒæˆç‚ºä¸‹ä¸€å€‹å…¨åŠ å™¨çš„é€²ä½è¼¸å…¥ä¹‹ä¸€ï¼Œè€ŒåŒæ™‚æ¯ä¸€å€‹å…¨åŠ å™¨éƒ½æœƒè¼¸å…¥å°æ‡‰ä½å…ƒçš„Aå’ŒBåšè¼¸å…¥ï¼Œä¸¦è¼¸å‡ºå°æ‡‰ä½å…ƒçš„Sumã€‚**
```verilog=1
module Ripple_Full_Adder(
  input  [3:0] A, B,
  output Cout,
  output [3:0] Sum
);
  //èª¿ç”¨å…¨åŠ å™¨(è©³ç´°è«‹åƒé–±å…¨åŠ å™¨)
  wire [3:0] c;
  Full_Adder F0(A[0], B[0],   0, Sum[0], c[1]),
	     F1(A[1], B[1],c[1], Sum[1], c[2]),
	     F2(A[2], B[2],c[2], Sum[2], c[3]),
	     F3(A[3], B[3],c[3], Sum[3], Cout); 
endmodule
```
&emsp;&emsp;**å¯¦ä½œä¸Šæˆ‘å€‘æ¡ç”¨éšå±¤æ–¹çš„è¨­è¨ˆï¼Œé‹ç”¨ä¸Šé¢çš„å…¨åŠ å™¨é›»è·¯è¨­è¨ˆï¼Œæˆ‘å€‘å¯ä»¥è¼•æ˜“çš„èª¿ç”¨å‡ºæˆ‘å€‘éœ€è¦çš„æ•¸é‡ï¼Œä½†æ˜¯è¦æ³¨æ„åˆ°æ¯å€‹è¼¸å…¥å’Œè¼¸å‡ºçš„å°æ‡‰é—œä¿‚æ˜¯å¦æ­£ç¢ºã€‚**
<br>

### ğŸ˜ˆ**å‰ç»é€²ä½åŠ æ³•å™¨ï¼ˆCarry Look-Ahead Adder, CLAï¼‰**
<div style="display: flex; justify-content: space-around;">
  <img src="https://hackmd.io/_uploads/HJ-SWhm-1e.png" alt="åœ–ç‰‡" width="50%">
  <img src="https://hackmd.io/_uploads/Bk9UWhmbye.png" alt="åœ–ç‰‡" width="50%">
</div>

- **boolean function**

\begin{cases}
 C_1=G_0+P_0C_0 \\
 C_2=G_1+P_1G_0+P_1P_0C_0 \\
 C_3=G_2+P_2G_1+P_2P_1G_0+P_2P_1P_0C_0
\end{cases}
\begin{cases}
 P_i=A_iâŠ•B_i \\
 G_i=A_iB_i \\
 S_i=P_iâŠ•C_i \\
 C_{i+1}=G_i+P_iC_i
\end{cases}

![åœ–ç‰‡](https://hackmd.io/_uploads/HJJ8PnQZ1l.png)

&emsp;&emsp;**ç†ç”±ç‚ºå¯ä»¥çŸ¥é“ï¼Œ$P_iå’ŒC_i$ä¹‹é–“å¯ä»¥ç”¨ä¾†ä»£æ›å…¨åŠ å™¨ï¼Œè€Œå…¶ä¸­$C_{i+1}=G_i+C_iP_i$å°¤å…¶é—œéµï¼Œ$C_1ã€C_2ã€C_3..$çš†å¯ç”±æ­¤æ¨å°ï¼Œä»¥ä¸‹æ˜¯æ¨å°:**

\begin{cases}
 C_1=G_0+C_0P_0 \\
 C_2=G_1+C_1P_1=G_1+(G_0+C_0P_0)P_1 =G_1+P_1G_0+P_0P_1C_0\\
C_3=G_2+C_2P_2=G_2+(G_1+P_1G_0+P_0P_1C_0)P_2=G_2+P_2G_1+P_2P_1G_0+P_2P_1P_0C_0
\end{cases}

- **æ¶æ§‹**
&emsp;&emsp;**å¯¦ä½œä¸Šæˆ‘å€‘å°‡å…¨åŠ æ³•å™¨æ‹†é–‹ä½¿ç”¨åŠåŠ æ³•å™¨ï¼Œä»¥å››ä½å…ƒç‚ºåŸºç¤ï¼Œæˆ‘å€‘ä½¿ç”¨å››å€‹åŠåŠ æ³•å™¨æ¥æ”¶4ä½å…ƒæ•¸Aå’ŒBåŒæ™‚è¼¸å‡ºå„ä½å…ƒçš„åŠ ç¸½å’Œé€²ä½ï¼Œæ¥è‘—æˆ‘å€‘å®‰è£ä¸Šè¶…å‰é€²ä½ç”¢ç”Ÿå™¨ï¼Œä»–å¯ä»¥ä¾æ“šå‰›å‰›æ¨è«–çš„é‚è¼¯é›»è·¯ï¼Œé«˜é€Ÿçš„é‹ç®—å‡ºå„ä½å…ƒçš„é€²ä½æ•¸å€¼ã€‚**

- CLAä¸»è¦æ¨¡çµ„
```verilog=1
module CLA(
  input  [3:0] A, B,
  input  C0,
  output [3:0] Sum,
  output Cout
);
  
  wire [3:0] P, G, C;
  Half_adder Ha0(A[0], B[0], P[0], G[0]),
	     Ha1(A[1], B[1], P[1], G[1]),
	     Ha2(A[2], B[2], P[2], G[2]),
	     Ha3(A[3], B[3], P[3], G[3]);
  
  CLG clg(P, G, C0, C);
  xor (Sum[0], P[0], C0),
      (Sum[1], P[1], C[0]),
      (Sum[2], P[2], C[1]),
      (Sum[3], P[3], C[2]);
  
  buf (Cout, C[3]);  
endmodule 
```
- CLGæ¨¡çµ„
```verilog=1
module CLG(
  input  [3:0] P, G, C0,
  output [3:0] C
);
  
  wire [5:0] And;
  and (And[0], P[0], C[0]),
      (And[1], P[1], G[0]),
      (And[2], P[1], P[0], C[0]),
      (And[3], P[2], G[1]),
      (And[4], P[2], P[1], G[0]),
      (And[5], P[2], P[1], P[0], C[0]);
  
  or (C[0], G[0], And[0]),
     (C[1], G[1], And[1], And[2]),
     (C[2], G[2], And[3], And[4], And[5]);
endmodule 
```
- Half_adderæ¨¡çµ„
```verilog=1
module Half_adder(
  input  A, B,
  output Sum, Cout
);
  
  xor ( Sum, A, B);
  and (Cout, A, B);
endmodule  
```
- æ¸¬è©¦æ¨¡çµ„
```verilog=1
`timescale 1ns/100ps
module stimulus;
  reg  [3:0] A, B;
  reg  C0;
  wire [3:0]Sum;
  wire Cout;
  
  
  CLA CA(A, B, C0, Sum, Cout);
  initial begin
    A=4'd0;B=4'd0;C0=0;
  end 
  always #50  A<=A+4'd2;
  always #100 B<=B+4'd3;
endmodule  
```
### ğŸ‘¿åé€²ä½åŠ æ³•å™¨(Decimal Adder)
![åœ–ç‰‡](https://hackmd.io/_uploads/S1XFvp4Wyg.png)
- **boolea function**
$Carry= Cout+Z_8Z_4+Z_8Z_2$
$S=Z+6$

- **åœ¨ BCD åŠ æ³•ä¸­ï¼Œç•¶å…©å€‹ BCD æ•¸å­—ç›¸åŠ çš„çµæœå¤§æ–¼ 1001 æ™‚ï¼Œå¯¦éš›ä¸Šç›¸ç•¶æ–¼äºŒé€²åˆ¶åŠ æ³•ä¸­å¾—åˆ°çš„æ•¸å€¼æ¯”é æœŸå°‘ç®—äº† 6ã€‚é€™æ˜¯å› ç‚º BCD ç·¨ç¢¼çš„æ¯å€‹åé€²ä½æ•¸å­—åªèƒ½è¡¨ç¤º 0 åˆ° 9ï¼Œå› æ­¤ç•¶äºŒé€²ä½çš„å’Œè¶…é 9 æ™‚ï¼Œæˆ‘å€‘éœ€è¦å°‡å…¶èª¿æ•´å›æ­£ç¢ºçš„ç¯„åœã€‚**

![Decimal-Adder-BCD-Adder-6](https://hackmd.io/_uploads/rkeScaE-yg.jpg)

- **æ¶æ§‹:**
&emsp;&emsp;**åœ¨é‚è¼¯é›»è·¯è¨­è¨ˆçš„æ¶æ§‹ä¸Šï¼Œæˆ‘å€‘çš„è·¯å¾‘æ‡‰è©²æ˜¯ï¼Œä¸€å€‹å››ä½å…ƒçš„é€£æ³¢é€²ä½åŠ æ³•å™¨ï¼Œä»–æœƒè² è²¬è™•ç†å…©å€‹è¼¸å…¥çš„è¨ˆç®—<span style="color:red">(è«‹æ³¨æ„æ­¤æ™‚è¨ˆç®—çš„ç¸½å’Œç‚ºäºŒé€²ä½æ•¸)</span>ï¼Œä¾æ“šçœŸå€¼è¡¨æˆ‘å€‘çŸ¥é“ç¸½è¼¸å‡ºçš„é€²ä½æ‡‰è©²è¦å¦‚ä½•è¨ˆç®—ï¼Œæ¥è‘—åªè¦æŠŠè¨ˆç®—çš„Z+Carryå°±å¯ä»¥è½‰æ›ç‚ºåé€²ä½çš„BCDç¢¼äº†ã€‚**

- **åé€²ä½åŠ æ³•å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Decimal_Adder(
  input  [3:0] A, B,
  input  Cin, 
  output [3:0] S,
  output Cout
);
  
  wire [3:0] Z;
  wire C;
  Ripple_Full_Adder rfa0(A, B, Cin, C, Z);
  
  wire [3:0] c; 
  wire A1, A2, O;
  
   and (A1, Z[3], Z[2]),
       (A2, Z[3], Z[1]);
   or  (O, C, A1, A2);
	
  assign c = O ? 4'b0110 : 4'b0000;
  
  Ripple_Full_Adder rfa1(Z, c, 1'b0, Cout, S);
endmodule 
```

- **é€£æ³¢é€²ä½å…¨åŠ æ³•å™¨æ¨¡çµ„**
```verilog=1
module Ripple_Full_Adder(
  input  [3:0] A, B,
  input  Cin,
  output Cout,
  output [3:0] Sum
);
  
  wire [3:0] c;
  Full_Adder F0(A[0], B[0], Cin, Sum[0], c[1]),
				 F1(A[1], B[1],c[1], Sum[1], c[2]),
				 F2(A[2], B[2],c[2], Sum[2], c[3]),
				 F3(A[3], B[3],c[3], Sum[3], Cout); 
endmodule 
```

- **å…¨åŠ æ³•å™¨æ¨¡çµ„**
```verilog=1
module Full_Adder(
  input  A, B, Cin,
  output Sum, Cout
);
  
 assign Sum  =A^B^Cin;
 assign Cout =A&B|A&Cin|B&Cin;
endmodule 
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module stimulus;
  reg  [3:0] A, B;
  reg  Cin; 
  wire [3:0]S;
  wire Cout;

  Decimal_Adder DA(A, B, Cin, S, Cout);
  initial begin
    A=4'd0;B=4'd0;Cin=0;
  end 
  always #50  A<=A+4'd2;
  always #100 B<=B+4'd3;
  always #400 Cin<=Cin+1;
endmodule 
```
- **ç”±æ–¼è©²é›»è·¯æ¶‰åŠå¤šå€‹å…ƒä»¶ï¼Œé‚è¼¯é—œä¿‚æ›´ç‚ºè¤‡é›œï¼Œä¹Ÿæ›´å®¹æ˜“å‡ºéŒ¯ï¼Œå¯«ç¨‹å¼ç¢¼çš„æ™‚å€™çµ•å°è¦éå¸¸æ³¨æ„å’Œå°å¿ƒ!**
# ğŸ‘»æ¸›æ³•å™¨(Subtractor)
- **æ¸›æ³•å™¨ï¼ˆSubtractorï¼‰æ˜¯ä¸€ç¨®æ•¸ä½é‚è¼¯é›»è·¯ï¼Œç”¨æ–¼åœ¨äºŒé€²åˆ¶ç³»çµ±ä¸­åŸ·è¡Œæ¸›æ³•é‹ç®—ã€‚å®ƒå’ŒåŠ æ³•å™¨ä¸€æ¨£ï¼Œæ˜¯æ§‹å»ºè¨ˆç®—æ©Ÿå’Œæ•¸ä½é›»è·¯çš„åŸºæœ¬çµ„ä»¶ä¹‹ä¸€ã€‚æ¸›æ³•å™¨å¯ä»¥æ ¹æ“šæ‡‰ç”¨éœ€æ±‚åˆ†ç‚ºã€ŒåŠæ¸›æ³•å™¨ï¼ˆHalf Subtractorï¼‰ã€å’Œã€Œå…¨æ¸›æ³•å™¨ï¼ˆFull Subtractorï¼‰ã€ã€‚**

### ğŸ”µåŠæ¸›æ³•å™¨(Half Subtractor)
<div style="display: flex; justify-content: space-around;">
  <img src="https://hackmd.io/_uploads/S1FZgvNbyl.png" alt="åœ–ç‰‡" width="70%">
  <img src="https://hackmd.io/_uploads/HkzhgPEZke.png" alt="åœ–ç‰‡" width="40%">
</div>

- **boolean function**
 $Diif=AâŠ•B$
 $Borr=A'B$

```verilog=1
module Half_Subtractor(
  input  A, B,
  output Diff, Borr
);
  
  wire BA;
  not (  BA, A);
  xor (Diff,  A, B);
  and (Borr, BA, B);
endmodule 
```

&emsp;&emsp;**å¯¦ä½œä¸Šæ˜¯æ¡ç”¨é¡ä¼¼åŠåŠ å™¨çš„é‚è¼¯ï¼Œå”¯ä¸€çš„å·®ç•°å°±æ˜¯å€Ÿä½æ™‚å€™è¼¸å…¥BAè€Œä¸æ˜¯Aã€‚**

### ğŸ”´å…¨æ¸›æ³•å™¨(Half Subtractor)
<div style="display: flex; justify-content: space-around;">
  <img src="https://hackmd.io/_uploads/SJCNED4b1l.png" alt="åœ–ç‰‡" width="70%">
  <img src="https://hackmd.io/_uploads/HJV8SwVbJl.png" alt="åœ–ç‰‡" width="35%">
</div>

- **boolean function**
 $Diif=AâŠ•BâŠ•Bin$
 $Borr=A'B+Bin(\overline{AâŠ•B})$

- **å…¨æ¸›å™¨æ¨¡çµ„**
```verilog=1
module Full_Subtractor(
  input  A, B, Bin,
  output Diff, Bout
);
  
  wire A1, BA, A2, X2, BX2;
  
  xor (Diff, A, B, Bin),  
      (  X2, A, B);
  not (  BA,  A),
      ( BX2, X2);
  and (  A1, BA,    B),
      (  A2, Bin, BX2);
  or  (Bout, A1, A2);
endmodule 
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module stimulus;
  reg  A, B, Bin;
  wire Diff, Bout;
  
  Full_Subtractor FS(A, B, Bin, Diff, Bout);
  initial begin
    A=0;B=0;Bin=0;
  end
  always #100 A<=A+1;
  always #200 B<=B+1; 
endmodule 
```
&emsp;&emsp;**å¯¦ä½œä¸Šæ˜¯æ¡ç”¨é¡ä¼¼å…¨åŠ å™¨çš„é‚è¼¯ï¼Œä½†æ˜¯ç‚ºäº†å› æ‡‰borrçš„é‚è¼¯é›»è·¯ï¼Œåšäº†æ¯”è¼ƒå¤šçš„wireå»è™•ç†ï¼Œä¹Ÿå› æ­¤æ›´å®¹æ˜“å‡ºéŒ¯ï¼Œéœ€è¦ç‰¹åˆ¥ç•™æ„!**

### ğŸ˜ˆé€£æ³¢å€Ÿä½å…¨æ¸›æ³•å™¨(Ripple Borrow Full Subtractor)
![åœ–ç‰‡](https://hackmd.io/_uploads/BJ2ayKE-1x.png)

- **æ¶æ§‹:**
&emsp;&emsp;**å¯¦ä½œæ–¹å¼ä¸»è¦å°±æ˜¯ä¸²é€£å…¨æ¸›æ³•å™¨ï¼Œæ¯ä¸€ä½çš„é€²ä½éƒ½æœƒè¢«å‚³å…¥ä¸‹ä¸€ä½ï¼ŒåŒæ™‚ä¹Ÿæœƒè¼¸å‡ºæ¯ä¸€ä½çš„å·®ã€‚** 

- **é€£æ³¢å…¨æ¸›æ³•å™¨æ¨¡çµ„**
```verilog=1
module Ripple_Full_Subtractor(
  input  [3:0] A, B,
  input  Bin, 
  output [3:0] Diff,
  output Bout
);
  
  wire [2:0] Bo;
  Full_Subtractor FS0(A[0], B[0],   Bin, Diff[0], Bo[0]),
		  FS1(A[1], B[1], Bo[0], Diff[1], Bo[1]),
		  FS2(A[2], B[2], Bo[1], Diff[2], Bo[2]),
		  FS3(A[3], B[3], Bo[2], Diff[3], Bout);
endmodule 
```
- **å…¨æ¸›å™¨æ¨¡çµ„**
```verilog=1
module Full_Subtractor(
  input  A, B, Bin,
  output Diff, Bout
);
  
  wire A1, BA, A2, X2, BX2;
  
  xor (Diff, A, B, Bin),  
      (  X2, A, B);
  not (  BA,  A),
      ( BX2, X2);
  and (  A1, BA,    B),
      (  A2, Bin, BX2);
  or  (Bout, A1, A2);
endmodule 
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module stimulus;
  reg  [3:0] A, B;
  reg  Bin;
  wire [3:0] Diff;
  wire Bout;
  
  Ripple_Full_Subtractor rfs(A, B, Bin, Diff, Bout);
  initial begin
        A=4'd0;B=4'd0;Bin=0;	
  end
  
  always #50  A<=A+4'd3;
  always #100 B<=B+4'd2;
endmodule 
```

&emsp;&emsp;**å¯¦ä½œä¸Šæ˜¯æ¡ç”¨é¡ä¼¼é€£æ³¢å…¨åŠ å™¨çš„é‚è¼¯ï¼Œéœ€è¦åŒæ™‚åƒç…§é€£æ³¢é€²ä½åŠ æ³•å™¨å’Œå…¨æ¸›å™¨**<br>

# ğŸ˜¼åŠ æ¸›æ³•å™¨ (Adder-Subtractor)
- **åŠ æ¸›æ³•å™¨ï¼ˆAdder-Subtractorï¼‰æ˜¯ä¸€ç¨®å¯ä»¥åŒæ™‚åŸ·è¡ŒåŠ æ³•èˆ‡æ¸›æ³•é‹ç®—çš„æ•¸ä½é›»è·¯ã€‚åœ¨é›»å­å·¥ç¨‹å’Œæ•¸ä½é›»è·¯ä¸­ï¼ŒåŠ æ¸›æ³•å™¨æ˜¯ä¸€å€‹éå¸¸é‡è¦çš„å…ƒä»¶ï¼Œå¸¸ç”¨æ–¼è¨ˆç®—å™¨ã€è™•ç†å™¨ä¸­çš„ç®—è¡“é‚è¼¯å–®å…ƒï¼ˆALUï¼‰ï¼Œä»¥åŠå„ç¨®åµŒå…¥å¼ç³»çµ±ä¸­ã€‚å…¶é‹ä½œä¸»è¦åŸºæ–¼å…¨åŠ æ³•å™¨ï¼ˆFull Adderï¼‰é›»è·¯ï¼Œä¸¦åˆ©è£œç¢¼ï¼ˆTwo's Complementï¼‰ä¾†å¯¦ç¾æ¸›æ³•ã€‚**
![åœ–ç‰‡](https://hackmd.io/_uploads/BkfPK3EWJl.png)
- **æ¶æ§‹:**
&emsp;&emsp;**å°±æ˜¯ä¸»è¦é‹ç”¨å…¨åŠ æ³•å™¨æ­é…äºŒçš„è£œæ•¸çš„é‹ç®—æ¦‚å¿µï¼Œå› ç‚ºA-Bç­‰åŒæ–¼A+B(BåšäºŒçš„è£œæ•¸)å¾—åˆ°çš„æ•¸å€¼ï¼Œæœ€å¾Œï¼Œå°±å¦‚åŒé€£æ³¢é€²ä½å™¨æˆ‘å€‘ä¹Ÿéœ€è¦ä¸€å€‹è¼¸å‡ºä¾†è¡¨é”æ•´é«”æœ€çµ‚çš„é€²ä½åˆ°ä¸‹ä¸€å€‹é‹ç®—ä¸­ï¼Œæˆ‘å€‘å¯ä»¥è—‰ç”±Cinå’ŒCoutçš„é‚è¼¯é›»è·¯ä¾†åˆ¤æ–·ï¼Œç•¶Cinç‚º1æ™‚å€™ä»£è¡¨å…©æ•¸æ˜¯åœ¨åšæ¸›æ³•ï¼Œåä¹‹åŒç†ï¼Œä½†æ˜¯æœ€å¾Œå°±æœƒæ³¨æ„åˆ°è¨ˆç®—å‡ºä¾†ç¶“å¸¸æœƒæœ‰ä¸€å€‹æº¢ä½çš„éŒ¯èª¤éœ€è¦ä¿®æ­£ï¼Œé—œæ–¼é€™é»æˆ‘å€‘<span style="color:red">æ¡ç”¨xor(Cout,Cin)å³å¯è™•ç†ã€‚</span>**

- **åŠ æ¸›æ³•å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Adder_Subtractor(
  input  [3:0] A, B,
  input  M,
  output [3:0] Sum,
  output Cout, Verify
);
    //ä½¿ç”¨XORæ˜¯å› ç‚ºæ ¹æ“šæ•¸ä½é‚è¼¯çš„åŸç†ï¼ŒB'M+BM' å°‡æœƒæ˜¯è¼¸å‡ºå¯ä»¥ç”¢ç”ŸåŠ æ¸›æ³•çš„æ•ˆæœã€‚
  wire [3:0] C, b;
  xor (b[0], B[0], M),
      (b[1], B[1], M),
      (b[2], B[2], M),
      (b[3], B[3], M),
      (Verify, Cout, C[2]);
		
  Full_Adder FA0(A[0], b[0],    M, Sum[0], C[0]),
	     FA1(A[1], b[1], C[0], Sum[1], C[1]),
	     FA2(A[2], b[2], C[1], Sum[2], C[2]),
             FA3(A[3], b[3], C[2], Sum[3], Cout);  
   
endmodule 
```

- **å…¨åŠ å™¨æ¨¡çµ„**
```verilog=1
module Full_Adder(
  input  A, B, Cin,
  output Sum, Cout
);
  
  wire A1, A2, A3;
  xor (Sum, A, B, Cin);
  
  and (A1, A,  B),
      (A2, A,Cin),
      (A3, B,Cin);
    
  or  (Cout, A1, A2, A3);
endmodule 
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module stimulus;
  reg  [3:0] A, B;
  reg  M;
  wire [3:0] Sum;
  wire Cout, Verify;
  
  Adder_Subtractor AS(A, B, M, Sum, Cout, Verify);
  
  initial begin
          A=4'b1111;B=4'b0000;M=1;
     #100 A=4'b1100;B=4'b0011;M=1;
     #100 A=4'b0011;B=4'b1100;M=1;
     #100 A=4'b0101;B=4'b0101;M=0;
     #100 A=4'b1010;B=4'b0101;M=0;
     #100 A=4'b1101;B=4'b1010;M=0;
  end
endmodule 
```

- **åƒè€ƒæ³¢å½¢åœ–:**
![åœ–ç‰‡](https://hackmd.io/_uploads/HkbxxpEZke.png)

# ğŸƒä¹˜æ³•å™¨ (Multiplier)

- **åœ¨æ•¸ä½é‚è¼¯ä¸­ï¼Œä¹˜æ³•å™¨çš„ç›®çš„æ˜¯è¨ˆç®—å…©å€‹æ•¸çš„ä¹˜ç©ã€‚å°æ–¼äºŒé€²åˆ¶æ•¸ï¼Œä¹˜æ³•çš„éç¨‹é¡ä¼¼æ–¼åé€²åˆ¶çš„ä¹˜æ³•ï¼Œé€éé€ä½ç›¸ä¹˜å’Œé€²ä½çš„æ–¹å¼ä¾†è¨ˆç®—çµæœã€‚å³åœ–1**
### ğŸ”´äºŒé€²ä½ä¹˜æ³•å™¨
<div style="display: flex; justify-content: space-around;">
  <img src="https://hackmd.io/_uploads/HyyldC4bJl.png" alt="åœ–ç‰‡" width="70%">
  <img src="https://hackmd.io/_uploads/rygKzd04bke.png" alt="åœ–ç‰‡"width="50%">
</div>

- **äºŒé€²ä½ä¹˜æ³•å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Binary_Multiplier(
  input  [1:0] A, B,
  output [3:0] C
);
  //åœ¨22ä¹˜æ³•å™¨çš„andé‚è¼¯å¯¦ç¾ï¼Œé‹ä¾†åšæ¥ä¸‹çš„é‹ç®—ã€‚
  wire A1, A2, A3;
  and (C[0], A[0], B[0]),
      (  A1, A[0], B[1]),
      (  A2, A[1], B[0]),
      (  A3, A[1], B[1]);
  //å¼•ç”¨åŠåŠ æ³•å™¨å–®å…ƒä¾†åšé‹ç®—ï¼Œè©³ç´°å¯ä»¥åƒé–±æ•¸ä½é‚è¼¯
  wire carry; 
  Half_Adder HA1(A1,    A2, C[1], carry),
	     HA2(A3, carry, C[2],  C[3]);
endmodule 
```
- **å…¨åŠ æ³•å™¨(çœç•¥)**
- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module Mul22_stimulus;
  reg  [1:0] A, B;
  wire [3:0] C;
  //æ¸¬è©¦ç¨‹å¼ç¢¼ç”¨ä»¥æ¸¬è©¦æ­£ç¢ºæ€§
  Binary_Multiplier BM(A, B, C);
  initial begin
       A=2'b0;B=2'b0;
  end
  always #50 A<=A+1;
  always #200 B<=B+1;
  
  initial 
    $monitor($realtime, " ns, A= %d, B= %d, C= %d", A, B, C);
endmodule  
```

&emsp;&emsp;**ä¹˜æ³•å™¨ç›¸å°è€Œè¨€å…¶å¯¦ä¸æ˜¯éå¸¸è¤‡é›œï¼Œä½†æ˜¯ä¸€æ—¦ä½æ•¸æ›´å¤šäº†å¦‚ä½•è™•ç†å°‡æœƒæ˜¯ä¸€å€‹å€¼å¾—ç•™æ„çš„æŒ‘æˆ°!**

# ğŸ‘¹å¤šå·¥å™¨ (Multiplexer, MUX)
![n_onemultiplexer_blockdiagram](https://hackmd.io/_uploads/HJ-rexSW1x.jpg)

- **å¤šå·¥å™¨ï¼ˆMultiplexerï¼Œç°¡ç¨± MUXï¼‰å’Œè§£å¤šå·¥å™¨ï¼ˆDemultiplexerï¼Œç°¡ç¨± DEMUXï¼‰æ˜¯æ•¸ä½é›»è·¯ä¸­å…©ç¨®é‡è¦çš„çµ„ä»¶ã€‚å®ƒå€‘åœ¨åŠŸèƒ½ä¸Šæ˜¯ç›¸å°çš„ï¼Œä¸»è¦å·®ç•°å¦‚ä¸‹ï¼š**

- **å¤šå·¥å™¨ (MUX)
    åŠŸèƒ½ï¼šå¤šå·¥å™¨æ˜¯ä¸€å€‹é¸æ“‡å™¨ï¼Œå®ƒæ ¹æ“šæ§åˆ¶ä¿¡è™Ÿé¸æ“‡ä¸€å€‹è¼¸å…¥ä¿¡è™Ÿä¸¦å°‡å…¶è½‰æ›ç‚ºå–®å€‹è¼¸å‡ºã€‚æ›å¥è©±èªªï¼ŒMUX æœƒå°‡å¤šå€‹è¼¸å…¥ä¿¡è™Ÿåˆä½µæˆä¸€å€‹è¼¸å‡ºä¿¡è™Ÿã€‚
    è¼¸å…¥èˆ‡è¼¸å‡ºï¼šæœ‰å¤šå€‹æ•¸æ“šè¼¸å…¥ï¼ˆå¦‚ 2n2n å€‹ï¼‰å’Œä¸€å€‹è¼¸å‡ºã€‚æ§åˆ¶ä¿¡è™Ÿçš„æ•¸é‡ nn ç”¨æ–¼é¸æ“‡å“ªä¸€å€‹è¼¸å…¥è¢«å‚³éåˆ°è¼¸å‡ºã€‚
    ç¤ºä¾‹ï¼šä¸€å€‹ 2-to-1 å¤šå·¥å™¨æœ‰å…©å€‹è¼¸å…¥ã€ä¸€å€‹è¼¸å‡ºå’Œä¸€å€‹æ§åˆ¶ä¿¡è™Ÿã€‚æ ¹æ“šæ§åˆ¶ä¿¡è™Ÿçš„å€¼ï¼Œé¸æ“‡å…¶ä¸­ä¸€å€‹è¼¸å…¥ä½œç‚ºè¼¸å‡ºã€‚**
    
- **è§£å¤šå·¥å™¨ (DEMUX)
    åŠŸèƒ½ï¼šè§£å¤šå·¥å™¨çš„åŠŸèƒ½æ­£å¥½èˆ‡å¤šå·¥å™¨ç›¸åã€‚å®ƒæ¥æ”¶å–®å€‹è¼¸å…¥ä¿¡è™Ÿä¸¦æ ¹æ“šæ§åˆ¶ä¿¡è™Ÿå°‡å…¶è½‰ç™¼åˆ°å¤šå€‹è¼¸å‡ºä¸­ã€‚ä¹Ÿå°±æ˜¯èªªï¼ŒDEMUX å¯ä»¥å°‡ä¸€å€‹æ•¸æ“šä¿¡è™Ÿåˆ†é…åˆ°å¤šå€‹è¼¸å‡ºã€‚
    è¼¸å…¥èˆ‡è¼¸å‡ºï¼šæœ‰ä¸€å€‹æ•¸æ“šè¼¸å…¥å’Œå¤šå€‹æ•¸æ“šè¼¸å‡ºï¼ˆå¦‚ 2n2n å€‹ï¼‰ã€‚æ§åˆ¶ä¿¡è™Ÿçš„æ•¸é‡ nn ç”¨æ–¼é¸æ“‡å°‡æ•¸æ“šè¼¸å‡ºåˆ°å“ªä¸€å€‹å…·é«”çš„è¼¸å‡ºç«¯ã€‚
    ç¤ºä¾‹ï¼šä¸€å€‹ 1-to-2 è§£å¤šå·¥å™¨æœ‰ä¸€å€‹è¼¸å…¥ã€å…©å€‹è¼¸å‡ºå’Œä¸€å€‹æ§åˆ¶ä¿¡è™Ÿã€‚æ ¹æ“šæ§åˆ¶ä¿¡è™Ÿçš„å€¼ï¼Œå°‡è¼¸å…¥ä¿¡è™Ÿè½‰ç™¼åˆ°å…¶ä¸­ä¸€å€‹è¼¸å‡ºã€‚**

- **ç¸½çµ
    å¤šå·¥å™¨ æ˜¯ç”¨ä¾†é¸æ“‡è¼¸å…¥ä¿¡è™Ÿä¸¦å°‡å…¶è½‰åŒ–ç‚ºå–®ä¸€è¼¸å‡ºï¼›è€Œ è§£å¤šå·¥å™¨ å‰‡æ˜¯ç”¨ä¾†å°‡å–®ä¸€è¼¸å…¥ä¿¡è™Ÿåˆ†é…åˆ°å¤šå€‹è¼¸å‡ºã€‚
    åœ¨å¯¦éš›æ‡‰ç”¨ä¸­ï¼Œå¤šå·¥å™¨é€šå¸¸ç”¨æ–¼æ•¸æ“šè·¯ç”±ï¼Œè€Œè§£å¤šå·¥å™¨å‰‡ç”¨æ–¼æ•¸æ“šåˆ†ç™¼ã€‚**

### 2 to 1 å¤šå·¥å™¨
![åœ–ç‰‡](https://hackmd.io/_uploads/SkJlWgHWyg.png)

- **2-1å¤šå·¥å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module MUL2_1(A, B, S, F);

	input A, B, S;
	output F;
	
	assign F = ~S & A | S & B;

endmodule
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1 ns/100 ps
module Test_tb;
reg A, B, S;
wire F;

MUL2_1 UUT(.A(A), .B(B), .S(S), .F(F));
// MUL2_1 UUT(A, B, S, F);

initial begin
	A = 1'b0; B = 1'b0; S = 1'b0;
	#100 B = 1'b1;
   #200 B = 1'b0; S = 1'b1;
   #100 B = 1'b1;
	#100 B = 1'b0;
	#100 S = 1'b0;
   #100 B = 1'b1; 	
end

always #100 A <= A + 1;  

initial #800 $finish;
initial $monitor($realtime, "ns %h %h %h %h", A, B, S, F);  

endmodule
```

### 4-to-1 å¤šå·¥å™¨

![VwgyX5p](https://hackmd.io/_uploads/rkf4fer-1l.png)
![åœ–ç‰‡](https://hackmd.io/_uploads/BkRHfxSWye.png)

- **4-1å¤šå·¥å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module MUL_4(I, S, F);
  input [3:0] I;
  input [1:0] S;
  output F;
  
  wire s1n, s0n;
  wire y0, y1, y2, y3;
  
  not S1n(s1n, S[1]);
  not S0n(s0n, S[0]);
  
  and O0(y0, I[0], s1n, s0n);
  and O1(y1, I[1], s1n, S[0]);
  and O2(y2, I[2], S[1], s0n);
  and O3(y3, I[3], S[1], S[0]);
  
  or out(F, y0, y1, y2, y3); 
endmodule 
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module MUL_4_tb;
  reg [3:0] I;
  reg [1:0] S;
  wire F;
  
  MUL_4 ml(I, S, F);
  initial begin
    I=4'b0000;S=2'b00;
	 #1200 I=4'b1111;
  end
  
  always #100 I<=I+1'b1;
  always #300 S<=S+1'b1;
  
  initial begin
    #1600 $finish;
	 $monitor($realtime, "ns %h %h %h", I, S, F);
  end 
endmodule 
```

### 1-to-4 è§£å¤šå·¥å™¨
![åœ–ç‰‡](https://hackmd.io/_uploads/rkY201S-1x.png)

- **1-4è§£å¤šå·¥å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module MUL_1_to_4(I, S0, S1, F0, F1, F2, F3);
  input  I;
  input  S0, S1;
  output F0, F1, F2, F3;
  
  wire s1n, s0n;
  not (s0n, S0);
  not (s1n, S1);
  
  and(F0, I, s1n, s0n);
  and(F1, I, s1n, S0);
  and(F2, I, S1, s0n);
  and(F3, I, S1, S0);
endmodule 
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module MUL_1_to_4_tb;
  reg I, S0, S1;
  wire F0, F1, F2, F3;
  
  MUL_1_to_4 ml(I, S0, S1, F0, F1, F2, F3);
  initial 
    begin
	       S0=0;S1=0;I=1;
	  #200 I<=0;
    end
  
  always #50  S0<=S0+1;
  always #100 S1<=S1+1;
  
  initial #400 $finish;
endmodule 
```
- **è¼¸å…¥è¨Šè™ŸIä¾æ“šé¸æ“‡ç·šçš„é–‹é—œè¢«æ§åˆ¶å°å…¥åˆ°ç‰¹å®šçš„è¼¸å‡ºå£ã€‚**
# ğŸ‘½è§£ç¢¼å™¨ (Decoder)
- **è§£ç¢¼å™¨ï¼ˆDecoderï¼‰ æ˜¯ä¸€ç¨®æ•¸ä½é‚è¼¯é›»è·¯ï¼Œå®ƒå°‡äºŒé€²åˆ¶æ•¸å­—ï¼ˆé€šå¸¸æ˜¯nä½å…ƒï¼‰è½‰æ›ç‚ºå”¯ä¸€çš„è¼¸å‡ºä¿¡è™Ÿï¼Œé€šå¸¸åœ¨ä¸€çµ„2^nå€‹è¼¸å‡ºä¸­åªæœƒæœ‰ä¸€å€‹è¼¸å‡ºç‚ºé«˜é›»å¹³ï¼ˆ1ï¼‰ï¼Œå…¶é¤˜å‰‡ç‚ºä½é›»å¹³ï¼ˆ0ï¼‰ã€‚è§£ç¢¼å™¨å»£æ³›æ‡‰ç”¨æ–¼è¨ˆç®—æ©Ÿç³»çµ±ã€å­˜å„²å™¨è§£ç¢¼ã€æ•¸æ“šé¸æ“‡ç­‰é ˜åŸŸã€‚**
### ğŸ”µäºŒå°å››è§£ç¢¼å™¨(Decoder2_to_4)
![decoder-300x169](https://hackmd.io/_uploads/HyW28ySb1g.png)

- **2-4è§£ç¢¼å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Decoder2_to_4(
  input  A, B, E,
  output [3:0] D
);
  
  wire BA, BB, BE;
  not  (BA, A),
       (BB, B),
       (BE, E);
  
  nand (D[0], BA, BB, BE),
       (D[1], BA,  B, BE),
       (D[2],  A, BB, BE),
       (D[3],  A,  B, BE);
endmodule 
```
- **æ¸¬è©¦æ¨¡çµ„**
``` verilog=1
`timescale 1ns/100ps
module Decoder2_to_4_tb;
  reg  A, B, E;
  wire [3:0] D;
  
  Decoder2_to_4 De(A, B, E, D);
  initial begin
      A=0; B=0; E=0;
  end
  always #100 B<=B+1;
  always #200 A<=A+1;
  always #400 E<=E+1;
endmodule 
```
![åœ–ç‰‡](https://hackmd.io/_uploads/rJS0SJrZ1x.png)
![åœ–ç‰‡](https://hackmd.io/_uploads/H1Var1SZkx.png)

- **3-8 è§£ç¢¼å™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Decoder3_to_8(
  input  A, B, C, E, // å¢åŠ  C ç‚ºè¼¸å…¥
  output [7:0] D    // å¢åŠ è¼¸å‡ºç‚º 8 ä½å…ƒ
);

  wire BA, BB, BC, BE;
  not  (BA, A),
       (BB, B),
       (BC, C),
       (BE, E);
  
  // ç”Ÿæˆ8å€‹è¼¸å‡º
  nand (D[0], BA, BB, BC, BE), // 000
       (D[1], BA, BB,  C, BE), // 001
       (D[2], BA,  B, BC, BE), // 010
       (D[3], BA,  B,  C, BE), // 011
       (D[4],  A, BB, BC, BE), // 100
       (D[5],  A, BB,  C, BE), // 101
       (D[6],  A,  B, BC, BE), // 110
       (D[7],  A,  B,  C, BE); // 111
endmodule 

```
- **æ¸¬è©¦æ¨¡çµ„**
``` verilog=1
`timescale 1ns/100ps
module Decoder3_to_8_tb;
  reg  A, B, C, E;
  wire [7:0] D; // å°‡è¼¸å‡ºæ”¹ç‚º 8 ä½å…ƒ
  
  Decoder3_to_8 De(A, B, C, E, D);
  initial begin
      A = 0; B = 0; C = 0; E = 0; // åˆå§‹åŒ–æ‰€æœ‰è¼¸å…¥
  end
  
  always #100 C <= ~C; // æ¯100nsåè½‰ C
  always #200 B <= ~B; // æ¯200nsåè½‰ B
  always #400 A <= ~A; // æ¯400nsåè½‰ A
  always #800 E <= ~E; // æ¯800nsåè½‰ E
endmodule 
```

&emsp;&emsp;**åœ¨æ¦‚å¿µå’ŒåŠŸèƒ½ä¸Šè§£ç¢¼å™¨å¾ˆå¥½ç†è§£ï¼Œå°±æ˜¯æŒ‰ç…§è‡ªå·±çš„éœ€æ±‚å¯ä»¥è—‰ç”±ANDé–˜å»è¨­è¨ˆé¡ä¼¼é–‹é—œçš„è¨­è¨ˆï¼Œè¼¸å…¥çš„é‚è¼¯æœƒå°æ‡‰åˆ°ç‰¹å®šçš„é–‹é—œï¼Œé—œéµåœ¨æ–¼å¦‚ä½•åœ¨æœªä¾†éˆæ´»æ‡‰ç”¨åˆ°è¨­è¨ˆä¸­ã€‚**

# ç·¨ç¢¼å™¨ (Encoder)

# ğŸ¤™**æ¯”è¼ƒå™¨(Comparator)** 
- **ç¨®é¡:æ¯”è¼ƒå™¨ã€å¹…åº¦æ¯”è¼ƒå™¨(Magnitude Comparator)etc.**
- **æ¯”è¼ƒå™¨ï¼ˆComparatorï¼‰æ˜¯ä¸€ç¨®ç”¨æ–¼æ¯”è¼ƒå…©å€‹æ•¸ä½ä¿¡è™Ÿçš„é›»è·¯ã€‚å®ƒå¯ä»¥ç¢ºå®šå…©å€‹è¼¸å…¥å€¼ä¹‹é–“çš„å¤§å°é—œä¿‚ï¼Œä¸¦æ ¹æ“šçµæœè¼¸å‡ºç›¸æ‡‰çš„ä¿¡è™Ÿã€‚æ¯”è¼ƒå™¨é€šå¸¸ç”¨æ–¼æ•¸æ“šè™•ç†ã€æ•¸å­—æ§åˆ¶ç³»çµ±å’Œå…¶ä»–éœ€è¦é€²è¡Œæ•¸æ“šæ¯”è¼ƒçš„æ‡‰ç”¨ã€‚**

### ğŸ”µæ¯”è¼ƒå™¨(Comparator)
![åœ–ç‰‡](https://hackmd.io/_uploads/BJJfWkHbyx.png)

- **boolean function**
$F_1=A'B$
$F_2=\overline{F_1+F_2}$
$F_3=AB'$

- **æ¯”è¼ƒå™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Comparator(
  input  A, B,
  output FA, FB, FX
);
  
  wire BA, BB;
  not (BA, A), (BB, B);
  
  and (FA, BA, B),(FB, BB, A);
	
  nor (FX, FA, FB);
endmodule 
```

### ğŸ”´å¤§å°æ¯”è¼ƒå™¨(Magnitude Comparator)
![åœ–ç‰‡](https://hackmd.io/_uploads/BJaaGyrb1l.png)

- **æ¶æ§‹:**
&emsp;&emsp;**è¼¸å…¥å…©å€‹å››ä½å…ƒçš„äºŒé€²ä½æ•¸æ¯”è¼ƒä»–å€‘çš„å¤§å°ï¼Œé‚è¼¯ä¸Šæ¡ç”¨å››å€‹æ¯”è¼ƒå™¨åˆ†åˆ¥è™•ç†å››å€‹ä½å…ƒçš„é‚è¼¯é‹ç®—ï¼Œç„¶å¾Œå› ç‚ºä»–å€‘æœ€çµ‚è¦è¢«çµ±ä¸€ç‚ºä¸€å€‹åˆ¤æ–·å¤§å°çš„è¼¸å‡ºï¼Œåƒè€ƒä»¥ä¸Šåœ–ç‰‡å®Œæˆç·šè·¯ä¸²æ¥å³å¯å¾—åˆ°ä¸€å€‹å¯ä»¥é”æˆæ­¤åŠŸèƒ½çš„é›»è·¯**

- **å¤§å°æ¯”è¼ƒå™¨ä¸»è¦æ¨¡çµ„**
```verilog=1
module Comparator4_to_4(
  input  [3:0]A, B,
  output ALB, AGB, AEB
);
  
  wire [3:0] FA, FB, FX;
  wire [6:0] AND;
  
  Comparator C3(A[3], B[3], FA[3], FB[3], FX[3]),
	     C2(A[2], B[2], FA[2], FB[2], FX[2]),
	     C1(A[1], B[1], FA[1], FB[1], FX[1]),
	     C0(A[0], B[0], FA[0], FB[0], FX[0]);
  
  and (AND[6], FX[3], FA[2]),
		(AND[5], FX[3], FB[2]),
		(AND[4], FX[3], FX[2], FA[1]),
		(AND[3], FX[3], FX[2], FB[1]),
		(AND[2], FX[3], FX[2], FX[1], FA[0]),
		(AND[1], FX[3], FX[2], FX[1], FB[0]),
		(   AEB, FX[3], FX[2], FX[1], FX[0]);
  
  or  (ALB, FA[3], AND[6], AND[4], AND[2]),
      (AGB, FB[3], AND[5], AND[3], AND[1]);
endmodule 
```

- **æ¯”è¼ƒå™¨æ¨¡çµ„**
```verilog=1
module Comparator(
  input  A, B,
  output FA, FB, FX
);
  
  wire BA, BB;
  not (BA, A), (BB, B);
  
  and (FA, BA, B),(FB, BB, A);
	
  nor (FX, FA, FB);
endmodule 
```

- **æ¸¬è©¦æ¨¡çµ„**
```verilog=1
`timescale 1ns/100ps
module Comparator4_to_4_tb;
  reg  [3:0] A, B;
  wire ALB, AGB, AEB;
  
  Comparator4_to_4 Comp4(A, B, ALB, AGB, AEB);
  initial begin
        A=4'd1;B=4'd3;
	 #50 A=4'd8;B=4'd8;
	 #50 A=4'd3;B=4'd6;
	 #50 A=4'd8;B=4'd4;
	 #50 A=4'd2;B=4'd9;
	 #50 ;
  end
endmodule 
```

- **æ¯”è¼ƒå™¨æ•´é«”çš„è¨­è¨ˆï¼Œå°±æ˜¯å¦‚åŒå‰é¢çš„è¨­è¨ˆæ€è·¯ã€‚**

### é–‚é–å™¨
- **ç›´åˆ°è¼¸å…¥ä¿¡è™Ÿåˆ‡æ›ç‹€æ…‹ä¹‹å‰ï¼Œéƒ½å¯ä»¥ç„¡é™æœŸçš„ç¶­æŒç•¶å‰ç‹€æ…‹ï¼Œå„ç¨®é–‚é–èˆ‡æ­£åå™¨çš„ä¸»è¦å·®ç•°åœ¨æ–¼ï¼Œè¼¸å…¥æ•¸ä»¥åŠé€™äº›è¼¸å…¥å½±éŸ¿å…¶ç‹€æ…‹çš„æ–¹å¼ï¼Œè€Œé–‚é–å±¬æœ€åŸºæœ¬çš„å…ƒä»¶ã€‚**
![maxresdefault](https://hackmd.io/_uploads/SJTFXuHfye.jpg)
```verilog=1
module La(
  input  Set, Reset,
  output reg Q, BQ
);
  
  always@(*)begin
	   if(Reset&&Set)begin
		  Q=Q;
		  BQ=BQ;
		end
		else if(Reset)begin
		  Q=0;
		  BQ=1;
		end
		else if(Set)begin
		  Q=1;
		  BQ=0;
		end
	 end
endmodule 
```

- **é€™æ˜¯åŸºæœ¬çš„SRé–‚é–å™¨é›»è·¯å¯¦ç¾**
```verilog=1
module La_Nand(
  input  Set, Reset,
  output reg Q, BQ
);
  
  wire B_Set, B_Reset;
  assign B_Set=~Set;
  assign B_Reset=~Reset;
			
  always@(*)begin
      Q=~(BQ&B_Set);
      BQ=~( Q&B_Reset);
  end
endmodule 
```
- **é€™æ˜¯NANDå‹å¼çš„å¯¦ç¾æ–¹å¼**